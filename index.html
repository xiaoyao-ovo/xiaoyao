<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»ˆæåˆ‡ç‰‡ç”Ÿæˆå™¨ | å°ç‘¶åˆ¶ä½œ</title>
    <style>
        :root {
            --primary-color: #ff7eb9;
            --secondary-color: #ff65a3;
            --light-pink: #ffcce0;
            --dark-pink: #e75480;
            --bg-color: #fff5f9;
        }
        body {
            font-family: 'Arial Rounded MT Bold', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: #5a3a4a;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(233, 84, 128, 0.1);
        }
        h1 {
            text-align: center;
            color: var(--dark-pink);
            margin-bottom: 10px;
            font-size: 2.2em;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }
        .subtitle {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .upload-section {
            background-color: var(--light-pink);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px dashed var(--primary-color);
            text-align: center;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 3px 10px rgba(255, 126, 185, 0.1);
        }
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }
        .control-item {
            flex: 1;
            min-width: 200px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: var(--dark-pink);
            font-weight: bold;
        }
        input[type="range"], select, input[type="number"] {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        input[type="file"] {
            display: none;
        }
        .file-upload-btn {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            display: inline-block;
            font-size: 1.1em;
            transition: all 0.3s;
            box-shadow: 0 3px 6px rgba(255, 101, 163, 0.2);
        }
        .file-upload-btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(255, 101, 163, 0.3);
        }
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s;
            box-shadow: 0 3px 6px rgba(255, 101, 163, 0.2);
            margin-right: 10px;
        }
        button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(255, 101, 163, 0.3);
        }
        button:disabled {
            background-color: #d3d3d3;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .preview-container {
            background-color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(255, 126, 185, 0.1);
            position: relative;
        }
        #outputCanvas {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            background-color: #f0f0f0;
            background-image: linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd),
                              linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            cursor: crosshair;
        }
        .footer {
            text-align: center;
            margin-top: 30px;
            color: var(--primary-color);
            font-size: 0.9em;
        }
        .author {
            font-weight: bold;
            color: var(--dark-pink);
        }
        .range-value {
            display: inline-block;
            width: 40px;
            text-align: right;
            margin-left: 10px;
        }
        .progress-container {
            margin: 20px 0;
        }
        .progress-bar {
            height: 15px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            width: 0%;
            transition: width 0.3s;
        }
        .advanced-panel {
            display: none;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }
        .slice-controls {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
            padding-right: 10px;
        }
        .slice-control {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .slice-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--dark-pink);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .slice-toggle {
            display: flex;
            align-items: center;
        }
        .slice-toggle label {
            margin-right: 10px;
            font-weight: normal;
        }
        .effect-panel {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #ddd;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        
         /* æ–°å¢ï¼šä¼˜åŒ–é¢œè‰²é€‰æ‹©å™¨æ ·å¼ */
        .color-control {
            margin-bottom: 15px;
        }
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 60px;
            height: 40px;
            border-radius: 5px;
            padding: 0;
            cursor: pointer;
            margin-bottom: 10px;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 3px;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .color-presets {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .preset {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .preset:hover {
            transform: scale(1.1);
        }
        
        /* æ–°å¢ï¼šå¡å¯†éªŒè¯ç›¸å…³æ ·å¼ */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .auth-box {
            background-color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        .auth-box h2 {
            color: var(--dark-pink);
            margin-top: 0;
        }
        .auth-input {
            width: 100%;
            padding: 12px;
            margin: 15px 0;
            border: 2px solid var(--light-pink);
            border-radius: 10px;
            font-size: 16px;
            text-align: center;
        }
        .auth-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        .auth-message {
            margin: 15px 0;
            color: var(--dark-pink);
            font-weight: bold;
            min-height: 20px;
        }
        .auth-error {
            color: #ff3333;
        }
        .auth-success {
            color: #33aa33;
        }
        .auth-footer {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            button {
                width: 100%;
                margin-bottom: 10px;
            }
            .control-item {
                min-width: 100%;
            }
            input[type="color"] {
                width: 50px;
                height: 35px;
            }
        }
    </style>
</head>
<body>
    <!-- æ–°å¢ï¼šå¡å¯†éªŒè¯è¦†ç›–å±‚ -->
    <div id="authOverlay" class="auth-overlay">
        <div class="auth-box">
            <h2>ğŸŒ¸ è¯·è¾“å…¥å¡å¯† ğŸŒ¸</h2>
            <p>è¯·è´­ä¹°å¡å¯†åè¾“å…¥ä»¥ä½¿ç”¨æœ¬å·¥å…·</p>
            <input type="text" id="authKeyInput" class="auth-input" placeholder="è¯·è¾“å…¥å¡å¯†">
            <div id="authMessage" class="auth-message"></div>
            <button id="authSubmitBtn">éªŒè¯å¡å¯†</button>
            <div class="auth-footer">
                <p>å¡å¯†é—®é¢˜è¯·è”ç³»: å°ç‘¶ğŸ§2924808817</p>
                <p>å½“å‰ç‰ˆæœ¬: 1.0.0</p>
            </div>
        </div>
    </div>
    
    <div class="container" id="mainContainer" style="display: none;">
        <h1>ğŸŒ¸ å°ç‘¶ã®åˆ‡ç‰‡ç”Ÿæˆ ğŸŒ¸</h1>
        <p class="subtitle">æˆ‘æ˜¯ä¸€ä¸ªäººç±» ä¸€ä¸ªäºº ç±»ç±»çš„TvT</p>
        
        <div class="upload-section">
            <label for="tilUpload" class="file-upload-btn">
                ğŸ“ ä¸Šä¼  .til é…ç½®æ–‡ä»¶
            </label>
            <input type="file" id="tilUpload" accept=".til">
            <p id="fileName" style="margin-top: 10px; color: var(--dark-pink);"></p>
        </div>
        
        <div class="controls">
            <h2 style="color: var(--dark-pink); margin-top: 0;">å…¨å±€è®¾ç½®</h2>
            
            <div class="control-group">
                <div class="control-item">
                    <label for="globalWidthPercent">å®½åº¦æ¯”ä¾‹ <span id="globalWidthPercentValue" class="range-value">80</span>%</label>
                    <input type="range" id="globalWidthPercent" min="10" max="200" value="80">
                </div>
                
                <div class="control-item">
                    <label for="globalHeightPercent">é«˜åº¦æ¯”ä¾‹ <span id="globalHeightPercentValue" class="range-value">80</span>%</label>
                    <input type="range" id="globalHeightPercent" min="10" max="200" value="80">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-item">
                    <label for="sliceColor">åˆ‡ç‰‡é¢œè‰²</label>
                    <div class="color-control">
                        <input type="color" id="sliceColor" value="#ff7eb9">
                        <div class="color-presets">
                            <div class="preset" style="background-color: #ff7eb9;" data-color="#ff7eb9"></div>
                            <div class="preset" style="background-color: #ff65a3;" data-color="#ff65a3"></div>
                            <div class="preset" style="background-color: #e75480;" data-color="#e75480"></div>
                            <div class="preset" style="background-color: #ffffff;" data-color="#ffffff"></div>
                            <div class="preset" style="background-color: #000000;" data-color="#000000"></div>
                        </div>
                    </div>
                </div>
                
                <div class="control-item">
                    <label for="cornerRadius">åœ†è§’åŠå¾„ <span id="cornerRadiusValue" class="range-value">10</span>px</label>
                    <input type="range" id="cornerRadius" min="0" max="50" value="10">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-item">
                    <label for="positionType">å¡«å……ä½ç½®</label>
                    <select id="positionType">
                        <option value="center">å±…ä¸­</option>
                        <option value="top-left">å·¦ä¸Š</option>
                        <option value="top-right">å³ä¸Š</option>
                        <option value="bottom-left">å·¦ä¸‹</option>
                        <option value="bottom-right">å³ä¸‹</option>
                    </select>
                </div>
                
                <div class="control-item">
                    <button id="toggleAdvancedBtn">é«˜çº§è®¾ç½® â–¼</button>
                </div>
            </div>
            
            <div id="advancedPanel" class="advanced-panel">
                <h3 style="color: var(--dark-pink); margin-top: 0;">å•ç‹¬è®¾ç½®æ¯ä¸ªåˆ‡ç‰‡</h3>
                <div class="slice-controls" id="sliceControlsContainer">
                    <p>è¯·å…ˆä¸Šä¼ .tilæ–‡ä»¶ä»¥æ˜¾ç¤ºåˆ‡ç‰‡æ§åˆ¶é€‰é¡¹</p>
                </div>
                
                <h3 style="color: var(--dark-pink); margin-top: 20px;">é˜´å½±è®¾ç½®</h3>
                <div class="control-group">
                    <div class="control-item">
                        <label for="shadowEnabled">å¯ç”¨é˜´å½±</label>
                        <input type="checkbox" id="shadowEnabled" style="width: auto;">
                    </div>
                    <div class="control-item">
                        <label for="shadowColor">é˜´å½±é¢œè‰²</label>
                        <div class="color-control">
                            <input type="color" id="shadowColor" value="#000000">
                            <div class="color-presets">
                                <div class="preset" style="background-color: #000000;" data-color="#000000"></div>
                                <div class="preset" style="background-color: #333333;" data-color="#333333"></div>
                                <div class="preset" style="background-color: #666666;" data-color="#666666"></div>
                                <div class="preset" style="background-color: #999999;" data-color="#999999"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-item">
                        <label for="shadowBlur">é˜´å½±æ¨¡ç³Š <span id="shadowBlurValue" class="range-value">10</span>px</label>
                        <input type="range" id="shadowBlur" min="0" max="50" value="10">
                    </div>
                    <div class="control-item">
                        <label for="shadowOffsetX">æ°´å¹³åç§» <span id="shadowOffsetXValue" class="range-value">5</span>%</label>
                        <input type="range" id="shadowOffsetX" min="-100" max="100" value="5">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-item">
                        <label for="shadowOffsetY">å‚ç›´åç§» <span id="shadowOffsetYValue" class="range-value">5</span>%</label>
                        <input type="range" id="shadowOffsetY" min="-100" max="100" value="5">
                    </div>
                    <div class="control-item">
                        <label for="shadowOpacity">é˜´å½±é€æ˜åº¦ <span id="shadowOpacityValue" class="range-value">50</span>%</label>
                        <input type="range" id="shadowOpacity" min="0" max="100" value="50">
                    </div>
                </div>
                
                <h3 style="color: var(--dark-pink); margin-top: 20px;">æè¾¹è®¾ç½®</h3>
                <div class="control-group">
                    <div class="control-item">
                        <label for="strokeEnabled">å¯ç”¨æè¾¹</label>
                        <input type="checkbox" id="strokeEnabled" style="width: auto;">
                    </div>
                    <div class="control-item">
                        <label for="strokeColor">æè¾¹é¢œè‰²</label>
                        <div class="color-control">
                            <input type="color" id="strokeColor" value="#ffffff">
                            <div class="color-presets">
                                <div class="preset" style="background-color: #ffffff;" data-color="#ffffff"></div>
                                <div class="preset" style="background-color: #000000;" data-color="#000000"></div>
                                <div class="preset" style="background-color: #ff0000;" data-color="#ff0000"></div>
                                <div class="preset" style="background-color: #00ff00;" data-color="#00ff00"></div>
                                <div class="preset" style="background-color: #0000ff;" data-color="#0000ff"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-item">
                        <label for="strokeWidth">æè¾¹å®½åº¦ <span id="strokeWidthValue" class="range-value">2</span>px</label>
                        <input type="range" id="strokeWidth" min="0" max="20" value="2">
                    </div>
                    <div class="control-item">
                        <label for="strokeBlur">æè¾¹æ¨¡ç³Š <span id="strokeBlurValue" class="range-value">0</span>px</label>
                        <input type="range" id="strokeBlur" min="0" max="10" value="0">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-item">
                        <label for="strokeType">æè¾¹æ ·å¼</label>
                        <select id="strokeType">
                            <option value="solid">å®çº¿</option>
                            <option value="dashed">è™šçº¿</option>
                        </select>
                    </div>
                    <div class="control-item" id="dashSettings" style="display: none;">
                        <label for="dashPattern">è™šçº¿æ ·å¼</label>
                        <input type="text" id="dashPattern" value="5,3" placeholder="ä¾‹å¦‚: 5,3">
                    </div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-bottom: 20px;">
            <button id="generateBtn">ç”Ÿæˆå›¾ç‰‡</button>
            <button id="saveBtn" disabled>ä¿å­˜å›¾ç‰‡</button>
            <button id="resetBtn">é‡ç½®æ‰€æœ‰</button>
        </div>
        
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress" id="progressBar"></div>
            </div>
            <p id="progressText" style="text-align: center; margin-top: 5px; color: var(--primary-color);"></p>
        </div>
        
        <div class="preview-container">
            <h2 style="color: var(--dark-pink); margin-top: 0;">ç”Ÿæˆé¢„è§ˆ</h2>
            <canvas id="outputCanvas"></canvas>
            <div class="tooltip" id="sliceTooltip"></div>
            <p style="color: #888; font-size: 0.9em;">(ç°è‰²ç½‘æ ¼ä»£è¡¨é€æ˜åŒºåŸŸï¼Œç‚¹å‡»å¯æŸ¥çœ‹åˆ‡ç‰‡ç¼–å·)</p>
        </div>
        
        <div class="footer">
            <p>æœ¬å·¥å…·ç”± <span class="author">å°ç‘¶</span> åˆ¶ä½œ | ç»ˆæåˆ‡ç‰‡å›¾ç‰‡ç”Ÿæˆå·¥å…·</p>
            <p>ğŸ’– æ„Ÿè°¢ä½¿ç”¨ï¼å¦‚æœ‰é—®é¢˜è¯·è”ç³»: å°ç‘¶ğŸ§2924808817</p>
            <p id="licenseInfo" style="font-size: 0.8em; color: #888;"></p>
        </div>
    </div>

    <script>
        // =============================================
        // å¡å¯†ç³»ç»Ÿé…ç½® (æ‚¨å¯ä»¥ä¿®æ”¹è¿™éƒ¨åˆ†)
        // =============================================
        
        // æœ‰æ•ˆå¡å¯†åˆ—è¡¨ (å®é™…åº”ç”¨ä¸­åº”ä»æœåŠ¡å™¨è·å–)
const VALID_KEYS = [
    // åŸæœ‰å¡å¯†
    {
        key: "XY2024-ABCD-EFGH-IJKL", // å¡å¯†
        maxUses: 999,                   // æœ€å¤§ä½¿ç”¨æ¬¡æ•°
        validUntil: "2099-12-31",      // æœ‰æ•ˆæœŸ
        used: 0                        // å·²ä½¿ç”¨æ¬¡æ•°
    },
    {
        key: "XY2024-MNOP-QRST-UVWX",
        maxUses: 999,
        validUntil: "2099-06-30",
        used: 0
    },
    {
        key: "XY2024-YZAB-CDEF-GHIJ",
        maxUses: 999,                 // 999è¡¨ç¤ºæ— é™æ¬¡
        validUntil: "2099-12-31",      // é•¿æœŸæœ‰æ•ˆ
        used: 0
    },

    // æ–°å¢50ä¸ªå®Œå…¨éšæœºçš„æ°¸ä¹…å¡å¯† (æ¯ä¸ªä½¿ç”¨æ¬¡æ•°5æ¬¡)
    { key: "7XIAOYAO9-KZ42-PL98-3RM6", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO5TQ-6V9D-2X8F-HS4K", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "B4XIAOYAO7N-3C8D-9F2G-5H1J", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO8L2-M4P6-Q9R3-S1T5", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "3XIAOYAO-K9J8-D2F4-G6H7", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO7X-5P3K-9M2N-8B4V", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "X6XIAOYAO3-C8B2-N5D7-F9G1", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO9F-2H5J-8K3L-7M4N", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "DXIAOYAO8Z-4V6B-9N1M-2K3L", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO4R-7T9Y-1U3I-5O8P", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "9XIAOYAO2-W4E6-R8T1-Y3U5", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO1S-5D7F-9G2H-4J6K", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "JXIAOYAO3K-8M2N-5B4V-6C7X", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO6Z-9Q1W-3E4R-7T8Y", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "5XIAOYAO7P-2L4K-9J8H-1G3F", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO3V-8B6N-9M1Q-4W7E", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "KXIAOYAO4D-9F2G-5H1J-8L3K", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO2X-5C7V-8B9N-1M4Q", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "8XIAOYAO1-R3T5-Y7U9-I2O4", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO9P-6L2K-4J8H-3G1F", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "MXIAOYAO5N-2B4V-6C7X-9Z8Q", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO4H-1J3K-7L8P-9O6I", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "2XIAOYAO6W-5E3R-7T9Y-1U4I", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO7C-8V5B-9N2M-1Q4W", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "QXIAOYAO9Z-3X6C-8V2B-5N7M", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO5D-2F4G-6H8J-1K3L", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "3XIAOYAO8P-9L1K-7J4H-2G5F", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO6B-4V9N-8M2Q-1W3E", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "VXIAOYAO7C-5X8Z-9Q2W-4E6R", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO8N-1M3Q-5W7E-9R2T", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "4XIAOYAO9Y-2U5I-8O3P-6I9O", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO1F-3G5H-7J9K-2L4P", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "ZXIAOYAO2Q-6W8E-3R7T-9Y1U", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO3M-5N7B-9V2C-8X4Z", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "9XIAOYAO4I-1O3P-6I8O-9P1I", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO7K-2J4H-6G8F-1D3S", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "WXIAOYAO5E-3R7T-9Y1U-4I2O", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO8V-6B9N-2M1Q-5W4E", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "5XIAOYAO6R-7T9Y-1U3I-8O4P", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO9C-4X8Z-3Q5W-7E2R", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "EXIAOYAO7T-2Y4U-6I8O-9P1I", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO2N-5M8B-9V3C-7X1Z", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "1XIAOYAO3H-4J6K-8L9P-2O5I", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO4D-7F9G-1H2J-5K3L", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "RXIAOYAO8T-3Y5U-7I9O-1P2I", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO6Q-9W2E-4R5T-7Y8U", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "7XIAOYAO9B-5N8V-2C4X-6Z9Q", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO1P-3L6K-9J8H-4G2F", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "TXIAOYAO5Y-1U3I-6O8P-9I1O", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "YAO8M-2N5B-7V9C-1X3Z", maxUses: 5, validUntil: "2099-12-31", used: 0 },
    { key: "6XIAOYAO4J-8H3G-5F1D-9S2A", maxUses: 5, validUntil: "2099-12-31", used: 0 }
];
        
// æœ¬åœ°å­˜å‚¨å‰ç¼€
        const STORAGE_PREFIX = "XY_SLICER_";
        
        // =============================================
        // ä¸»ç¨‹åº
        // =============================================
        
        // DOMå…ƒç´ 
        const authOverlay = document.getElementById('authOverlay');
        const mainContainer = document.getElementById('mainContainer');
        const authKeyInput = document.getElementById('authKeyInput');
        const authSubmitBtn = document.getElementById('authSubmitBtn');
        const authMessage = document.getElementById('authMessage');
        const licenseInfo = document.getElementById('licenseInfo');
        
        const tilUpload = document.getElementById('tilUpload');
        const generateBtn = document.getElementById('generateBtn');
        const saveBtn = document.getElementById('saveBtn');
        const resetBtn = document.getElementById('resetBtn');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d', { willReadFrequently: true });
        const fileName = document.getElementById('fileName');
        const globalWidthPercent = document.getElementById('globalWidthPercent');
        const globalWidthPercentValue = document.getElementById('globalWidthPercentValue');
        const globalHeightPercent = document.getElementById('globalHeightPercent');
        const globalHeightPercentValue = document.getElementById('globalHeightPercentValue');
        const cornerRadius = document.getElementById('cornerRadius');
        const cornerRadiusValue = document.getElementById('cornerRadiusValue');
        const sliceColor = document.getElementById('sliceColor');
        const positionType = document.getElementById('positionType');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const toggleAdvancedBtn = document.getElementById('toggleAdvancedBtn');
        const advancedPanel = document.getElementById('advancedPanel');
        const sliceControlsContainer = document.getElementById('sliceControlsContainer');
        const shadowEnabled = document.getElementById('shadowEnabled');
        const shadowColor = document.getElementById('shadowColor');
        const shadowBlur = document.getElementById('shadowBlur');
        const shadowBlurValue = document.getElementById('shadowBlurValue');
        const shadowOffsetX = document.getElementById('shadowOffsetX');
        const shadowOffsetXValue = document.getElementById('shadowOffsetXValue');
        const shadowOffsetY = document.getElementById('shadowOffsetY');
        const shadowOffsetYValue = document.getElementById('shadowOffsetYValue');
        const shadowOpacity = document.getElementById('shadowOpacity');
        const shadowOpacityValue = document.getElementById('shadowOpacityValue');
        const strokeEnabled = document.getElementById('strokeEnabled');
        const strokeColor = document.getElementById('strokeColor');
        const strokeWidth = document.getElementById('strokeWidth');
        const strokeWidthValue = document.getElementById('strokeWidthValue');
        const strokeBlur = document.getElementById('strokeBlur');
        const strokeBlurValue = document.getElementById('strokeBlurValue');
        const strokeType = document.getElementById('strokeType');
        const dashSettings = document.getElementById('dashSettings');
        const dashPattern = document.getElementById('dashPattern');
        const sliceTooltip = document.getElementById('sliceTooltip');
        
        // å˜é‡
        let slices = [];
        let generated = false;
        let originalLayout = { width: 0, height: 0 };
        let advancedPanelOpen = false;
        let hoveredSliceIndex = -1;
        let currentLicense = null;
        
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        function initEventListeners() {
            // å¡å¯†éªŒè¯ç›¸å…³
            authSubmitBtn.addEventListener('click', validateLicense);
            authKeyInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') validateLicense();
            });
            
            // ä¸»ç¨‹åºäº‹ä»¶
            tilUpload.addEventListener('change', handleTilUpload);
            generateBtn.addEventListener('click', generateImage);
            saveBtn.addEventListener('click', saveImage);
            resetBtn.addEventListener('click', resetAll);
            toggleAdvancedBtn.addEventListener('click', toggleAdvancedPanel);
            
            // æ§åˆ¶é¡¹äº‹ä»¶
            globalWidthPercent.addEventListener('input', updateGlobalWidthPercent);
            globalHeightPercent.addEventListener('input', updateGlobalHeightPercent);
            cornerRadius.addEventListener('input', updateCornerRadius);
            
            // é˜´å½±è®¾ç½®äº‹ä»¶
            shadowEnabled.addEventListener('change', updateShadowSettings);
            shadowBlur.addEventListener('input', updateShadowBlur);
            shadowOffsetX.addEventListener('input', updateShadowOffsetX);
            shadowOffsetY.addEventListener('input', updateShadowOffsetY);
            shadowOpacity.addEventListener('input', updateShadowOpacity);
            
            // æè¾¹è®¾ç½®äº‹ä»¶
            strokeEnabled.addEventListener('change', updateStrokeSettings);
            strokeWidth.addEventListener('input', updateStrokeWidth);
            strokeBlur.addEventListener('input', updateStrokeBlur);
            strokeType.addEventListener('change', updateStrokeType);
            
            // é¢œè‰²é¢„è®¾ç‚¹å‡»äº‹ä»¶
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('preset')) {
                    const color = e.target.getAttribute('data-color');
                    const colorInput = e.target.closest('.color-control').querySelector('input[type="color"]');
                    colorInput.value = color;
                    colorInput.dispatchEvent(new Event('input'));
                }
            });
            
            // é¢œè‰²è¾“å…¥å˜åŒ–äº‹ä»¶
            sliceColor.addEventListener('input', updateColorPreview);
            shadowColor.addEventListener('input', updateColorPreview);
            strokeColor.addEventListener('input', updateColorPreview);
            
            // ç”»å¸ƒäº¤äº’äº‹ä»¶
            outputCanvas.addEventListener('click', handleCanvasClick);
            outputCanvas.addEventListener('mousemove', handleCanvasHover);
            
            // åˆå§‹åŒ–å·¥å…·æç¤º
            document.addEventListener('mousemove', moveTooltip);
        }
        
        // =============================================
        // å¡å¯†éªŒè¯åŠŸèƒ½
        // =============================================
        
        // éªŒè¯å¡å¯†
        function validateLicense() {
            const key = authKeyInput.value.trim();
            authMessage.textContent = '';
            authMessage.className = 'auth-message';
            
            if (!key) {
                showAuthMessage('è¯·è¾“å…¥å¡å¯†', 'auth-error');
                return;
            }
            
            // æ£€æŸ¥å¡å¯†æ˜¯å¦æœ‰æ•ˆ
            const license = VALID_KEYS.find(k => k.key === key);
            
            if (!license) {
                showAuthMessage('æ— æ•ˆçš„å¡å¯†', 'auth-error');
                return;
            }
            
            // æ£€æŸ¥æœ‰æ•ˆæœŸ
            const today = new Date();
            const validUntil = new Date(license.validUntil);
            
            if (today > validUntil) {
                showAuthMessage('å¡å¯†å·²è¿‡æœŸ', 'auth-error');
                return;
            }
            
            // æ£€æŸ¥ä½¿ç”¨æ¬¡æ•°
            const storageKey = STORAGE_PREFIX + key;
            const storedData = localStorage.getItem(storageKey);
            let usedCount = 0;
            
            if (storedData) {
                try {
                    const data = JSON.parse(storedData);
                    usedCount = data.used || 0;
                } catch (e) {
                    console.error('è§£æå­˜å‚¨æ•°æ®å¤±è´¥', e);
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§ä½¿ç”¨æ¬¡æ•°
            if (license.maxUses !== 999 && usedCount >= license.maxUses) {
                showAuthMessage('å¡å¯†ä½¿ç”¨æ¬¡æ•°å·²è¾¾ä¸Šé™', 'auth-error');
                return;
            }
            
            // éªŒè¯é€šè¿‡
            currentLicense = {
                key: license.key,
                maxUses: license.maxUses,
                validUntil: license.validUntil,
                used: usedCount + 1
            };
            
            // ä¿å­˜ä½¿ç”¨è®°å½•
            localStorage.setItem(storageKey, JSON.stringify({
                used: currentLicense.used,
                lastUsed: new Date().toISOString()
            }));
            
            showAuthMessage('éªŒè¯æˆåŠŸï¼æ­£åœ¨åŠ è½½å·¥å…·...', 'auth-success');
            
            // 3ç§’åéšè—éªŒè¯ç•Œé¢
            setTimeout(() => {
                authOverlay.style.display = 'none';
                mainContainer.style.display = 'block';
                updateLicenseInfo();
            }, 2000);
        }
        
        // æ˜¾ç¤ºéªŒè¯æ¶ˆæ¯
        function showAuthMessage(message, className = '') {
            authMessage.textContent = message;
            authMessage.className = 'auth-message ' + className;
        }
        
        // æ›´æ–°è®¸å¯è¯ä¿¡æ¯æ˜¾ç¤º
        function updateLicenseInfo() {
            if (!currentLicense) return;
            
            const validDate = new Date(currentLicense.validUntil).toLocaleDateString();
            let usageText = '';
            
            if (currentLicense.maxUses === 999) {
                usageText = 'æ— é™æ¬¡ä½¿ç”¨';
            } else {
                usageText = `å·²ä½¿ç”¨ ${currentLicense.used} æ¬¡ (å…± ${currentLicense.maxUses} æ¬¡)`;
            }
            
            licenseInfo.textContent = `å¡å¯†: ${currentLicense.key} | æœ‰æ•ˆæœŸè‡³: ${validDate} | ${usageText}`;
        }
        
        // =============================================
        // ä¸»ç¨‹åºåŠŸèƒ½ (ä¸åŸä»£ç ç›¸åŒ)
        // =============================================
        
        // æ›´æ–°å…¨å±€å®½åº¦ç™¾åˆ†æ¯”æ˜¾ç¤º
        function updateGlobalWidthPercent() {
            globalWidthPercentValue.textContent = globalWidthPercent.value;
        }
        
        // æ›´æ–°å…¨å±€é«˜åº¦ç™¾åˆ†æ¯”æ˜¾ç¤º
        function updateGlobalHeightPercent() {
            globalHeightPercentValue.textContent = globalHeightPercent.value;
        }
        
        // å¤„ç†.tilæ–‡ä»¶ä¸Šä¼ 
        function handleTilUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            fileName.textContent = `å·²é€‰æ‹©: ${file.name}`;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                parseTilFile(event.target.result);
                updateGenerateButtonState();
                createSliceControls();
            };
            reader.readAsText(file);
        }
        
        // è§£æ.tilæ–‡ä»¶
        function parseTilFile(content) {
            slices = [];
            const lines = content.split('\n');
            let maxX = 0, maxY = 0;
            
            lines.forEach(line => {
                // è§£æåˆ‡ç‰‡ä¿¡æ¯
                if (line.startsWith('SOURCE_RECT=')) {
                    const rectStr = line.split('=')[1].trim();
                    const [x, y, width, height] = rectStr.split(',').map(Number);
                    
                    slices.push({
                        x, y, width, height,
                        widthPercent: 80,  // é»˜è®¤å®½åº¦ç™¾åˆ†æ¯”æ”¹ä¸º80%
                        heightPercent: 80, // é»˜è®¤é«˜åº¦ç™¾åˆ†æ¯”æ”¹ä¸º80%
                        visible: true
                    });
                    
                    // è®¡ç®—åŸå§‹å¸ƒå±€å°ºå¯¸
                    maxX = Math.max(maxX, x + width);
                    maxY = Math.max(maxY, y + height);
                }
            });
            
            originalLayout.width = maxX;
            originalLayout.height = maxY;
        }
        
        // åˆ›å»ºåˆ‡ç‰‡æ§åˆ¶é¡¹
        function createSliceControls() {
            sliceControlsContainer.innerHTML = '';
            
            if (slices.length === 0) {
                sliceControlsContainer.innerHTML = '<p>æ²¡æœ‰æ‰¾åˆ°åˆ‡ç‰‡é…ç½®</p>';
                return;
            }
            
            slices.forEach((slice, index) => {
                const sliceControl = document.createElement('div');
                sliceControl.className = 'slice-control';
                sliceControl.innerHTML = `
                    <div class="slice-title">
                        <span>åˆ‡ç‰‡ ${index + 1} (${slice.width}Ã—${slice.height}px)</span>
                        <div class="slice-toggle">
                            <label for="sliceVisible-${index}">æ˜¾ç¤º</label>
                            <input type="checkbox" class="slice-visible" id="sliceVisible-${index}" 
                                   ${slice.visible ? 'checked' : ''} data-index="${index}">
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="control-item">
                            <label for="sliceWidthPercent-${index}">å®½åº¦æ¯”ä¾‹ <span id="sliceWidthPercentValue-${index}" class="range-value">${slice.widthPercent}</span>%</label>
                            <input type="range" class="slice-width-percent" id="sliceWidthPercent-${index}" 
                                   min="10" max="200" value="${slice.widthPercent}" data-index="${index}">
                        </div>
                        <div class="control-item">
                            <label for="sliceHeightPercent-${index}">é«˜åº¦æ¯”ä¾‹ <span id="sliceHeightPercentValue-${index}" class="range-value">${slice.heightPercent}</span>%</label>
                            <input type="range" class="slice-height-percent" id="sliceHeightPercent-${index}" 
                                   min="10" max="200" value="${slice.heightPercent}" data-index="${index}">
                        </div>
                    </div>
                `;
                sliceControlsContainer.appendChild(sliceControl);
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬
                document.getElementById(`sliceWidthPercent-${index}`).addEventListener('input', function() {
                    const idx = parseInt(this.getAttribute('data-index'));
                    slices[idx].widthPercent = parseInt(this.value);
                    document.getElementById(`sliceWidthPercentValue-${idx}`).textContent = this.value;
                });
                
                document.getElementById(`sliceHeightPercent-${index}`).addEventListener('input', function() {
                    const idx = parseInt(this.getAttribute('data-index'));
                    slices[idx].heightPercent = parseInt(this.value);
                    document.getElementById(`sliceHeightPercentValue-${idx}`).textContent = this.value;
                });
                
                document.getElementById(`sliceVisible-${index}`).addEventListener('change', function() {
                    const idx = parseInt(this.getAttribute('data-index'));
                    slices[idx].visible = this.checked;
                });
            });
        }
        
        // æ›´æ–°é¢œè‰²é¢„è§ˆ
        function updateColorPreview(e) {
            // é€šç”¨é¢œè‰²é¢„è§ˆæ›´æ–°
            const color = e.target.value;
            // å¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ ç‰¹å®šé¢„è§ˆå…ƒç´ çš„æ›´æ–°
        }
        
        // åˆ‡æ¢é«˜çº§é¢æ¿
        function toggleAdvancedPanel() {
            advancedPanelOpen = !advancedPanelOpen;
            if (advancedPanelOpen) {
                advancedPanel.style.display = 'block';
                toggleAdvancedBtn.innerHTML = 'é«˜çº§è®¾ç½® â–²';
            } else {
                advancedPanel.style.display = 'none';
                toggleAdvancedBtn.innerHTML = 'é«˜çº§è®¾ç½® â–¼';
            }
        }
        
        // æ›´æ–°åœ†è§’åŠå¾„æ˜¾ç¤º
        function updateCornerRadius() {
            cornerRadiusValue.textContent = cornerRadius.value;
        }
        
        // æ›´æ–°é˜´å½±æ¨¡ç³Š
        function updateShadowBlur() {
            shadowBlurValue.textContent = shadowBlur.value;
        }
        
        // æ›´æ–°é˜´å½±æ°´å¹³åç§»
        function updateShadowOffsetX() {
            shadowOffsetXValue.textContent = shadowOffsetX.value;
        }
        
        // æ›´æ–°é˜´å½±å‚ç›´åç§»
        function updateShadowOffsetY() {
            shadowOffsetYValue.textContent = shadowOffsetY.value;
        }
        
        // æ›´æ–°é˜´å½±é€æ˜åº¦
        function updateShadowOpacity() {
            shadowOpacityValue.textContent = shadowOpacity.value;
        }
        
        // æ›´æ–°æè¾¹å®½åº¦
        function updateStrokeWidth() {
            strokeWidthValue.textContent = strokeWidth.value;
        }
        
        // æ›´æ–°æè¾¹æ¨¡ç³Š
        function updateStrokeBlur() {
            strokeBlurValue.textContent = strokeBlur.value;
        }
        
        // æ›´æ–°æè¾¹ç±»å‹
        function updateStrokeType() {
            dashSettings.style.display = strokeType.value === 'dashed' ? 'block' : 'none';
        }
        
        // æ›´æ–°é˜´å½±è®¾ç½®
        function updateShadowSettings() {
            // ç”Ÿæˆæ—¶å¤„ç†
        }
        
        // æ›´æ–°æè¾¹è®¾ç½®
        function updateStrokeSettings() {
            // ç”Ÿæˆæ—¶å¤„ç†
        }
        
        // æ›´æ–°ç”ŸæˆæŒ‰é’®çŠ¶æ€
        function updateGenerateButtonState() {
            generateBtn.disabled = slices.length === 0;
        }
        
        // ç”Ÿæˆå›¾ç‰‡
        function generateImage() {
            if (slices.length === 0) {
                alert('è¯·å…ˆä¸Šä¼ æœ‰æ•ˆçš„.tilæ–‡ä»¶');
                return;
            }
            
            // è®¾ç½®ç”»å¸ƒå¤§å°ä¸ºåŸå§‹å¸ƒå±€å°ºå¯¸
            outputCanvas.width = originalLayout.width;
            outputCanvas.height = originalLayout.height;
            
            // æ¸…é™¤ç”»å¸ƒä¸ºå®Œå…¨é€æ˜
            ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // è·å–ç”¨æˆ·è®¾ç½®
            const globalWidthPct = parseInt(globalWidthPercent.value) / 100;
            const globalHeightPct = parseInt(globalHeightPercent.value) / 100;
            const radius = parseInt(cornerRadius.value);
            const position = positionType.value;
            
            // é˜´å½±è®¾ç½®
            const useShadow = shadowEnabled.checked;
            const shadowColorValue = shadowColor.value;
            const shadowBlurValue = parseInt(shadowBlur.value);
            const shadowOffsetXValue = parseInt(shadowOffsetX.value) / 100;
            const shadowOffsetYValue = parseInt(shadowOffsetY.value) / 100;
            const shadowOpacityValue = parseInt(shadowOpacity.value) / 100;
            
            // æè¾¹è®¾ç½®
            const useStroke = strokeEnabled.checked;
            const strokeColorValue = strokeColor.value;
            const strokeWidthValue = parseInt(strokeWidth.value);
            const strokeBlurValue = parseInt(strokeBlur.value);
            const strokeTypeValue = strokeType.value;
            const dashPatternValue = strokeTypeValue === 'dashed' ? 
                dashPattern.value.split(',').map(Number) : [];
            
            // æ›´æ–°è¿›åº¦
            progressBar.style.width = '0%';
            progressText.textContent = 'å‡†å¤‡ç”Ÿæˆ...';
            
            // åˆ†æ‰¹å¤„ç†ä»¥é¿å…UIé˜»å¡
            let processed = 0;
            const batchSize = 5;
            
            function processBatch() {
                const batchEnd = Math.min(processed + batchSize, slices.length);
                
                for (let i = processed; i < batchEnd; i++) {
                    const slice = slices[i];
                    if (!slice.visible) {
                        processed++;
                        continue;
                    }
                    
                    // ä½¿ç”¨å•ç‹¬è®¾ç½®æˆ–å…¨å±€è®¾ç½®
                    const widthPct = (slice.widthPercent !== 80) ? (slice.widthPercent / 100) : globalWidthPct;
                    const heightPct = (slice.heightPercent !== 80) ? (slice.heightPercent / 100) : globalHeightPct;
                    
                    const fillWidth = slice.width * widthPct;
                    const fillHeight = slice.height * heightPct;
                    
                    // è®¡ç®—å¡«å……ä½ç½®
                    let fillX, fillY;
                    switch(position) {
                        case 'top-left':
                            fillX = slice.x;
                            fillY = slice.y;
                            break;
                        case 'top-right':
                            fillX = slice.x + slice.width - fillWidth;
                            fillY = slice.y;
                            break;
                        case 'bottom-left':
                            fillX = slice.x;
                            fillY = slice.y + slice.height - fillHeight;
                            break;
                        case 'bottom-right':
                            fillX = slice.x + slice.width - fillWidth;
                            fillY = slice.y + slice.height - fillHeight;
                            break;
                        default: // center
                            fillX = slice.x + (slice.width - fillWidth) / 2;
                            fillY = slice.y + (slice.height - fillHeight) / 2;
                    }
                    
                    // ç»˜åˆ¶é˜´å½±
                    if (useShadow) {
                        ctx.save();
                        ctx.fillStyle = shadowColorValue;
                        ctx.globalAlpha = shadowOpacityValue;
                        ctx.filter = `blur(${shadowBlurValue}px)`;
                        
                        const shadowOffsetX = slice.width * shadowOffsetXValue;
                        const shadowOffsetY = slice.height * shadowOffsetYValue;
                        
                        roundRect(
                            ctx, 
                            fillX + shadowOffsetX, 
                            fillY + shadowOffsetY, 
                            fillWidth, 
                            fillHeight, 
                            radius
                        );
                        ctx.restore();
                    }
                    
                    // ç»˜åˆ¶å¡«å……
                    ctx.fillStyle = sliceColor.value;
                    roundRect(ctx, fillX, fillY, fillWidth, fillHeight, radius);
                    
                    // ç»˜åˆ¶æè¾¹
                    if (useStroke && strokeWidthValue > 0) {
                        ctx.save();
                        ctx.strokeStyle = strokeColorValue;
                        ctx.lineWidth = strokeWidthValue;
                        
                        if (strokeBlurValue > 0) {
                            ctx.filter = `blur(${strokeBlurValue}px)`;
                        }
                        
                        if (strokeTypeValue === 'dashed' && dashPatternValue.length >= 2) {
                            ctx.setLineDash(dashPatternValue);
                        } else {
                            ctx.setLineDash([]);
                        }
                        
                        roundRect(ctx, fillX, fillY, fillWidth, fillHeight, radius, true);
                        ctx.restore();
                    }
                    
                    processed++;
                    
                    // æ›´æ–°è¿›åº¦
                    const progress = Math.floor((processed / slices.length) * 100);
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `æ­£åœ¨ç”Ÿæˆ: ${progress}% (${processed}/${slices.length})`;
                }
                
                if (processed < slices.length) {
                    setTimeout(processBatch, 0);
                } else {
                    // ç”Ÿæˆå®Œæˆ
                    generated = true;
                    saveBtn.disabled = false;
                    progressText.textContent = `ç”Ÿæˆå®Œæˆ! å…± ${slices.length} ä¸ªåˆ‡ç‰‡`;
                    
                    // 3ç§’åé‡ç½®è¿›åº¦æ–‡æœ¬
                    setTimeout(() => {
                        progressText.textContent = 'å‡†å¤‡å°±ç»ª';
                    }, 3000);
                }
            }
            
            processBatch();
        }
        
        // ç»˜åˆ¶åœ†è§’çŸ©å½¢ï¼ˆæ”¯æŒæè¾¹ï¼‰
        function roundRect(ctx, x, y, width, height, radius, stroke = false) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            
            if (stroke) {
                ctx.stroke();
            } else {
                ctx.fill();
            }
        }
        
        // å¤„ç†ç”»å¸ƒç‚¹å‡»
        function handleCanvasClick(e) {
            if (!generated) return;
            
            const rect = outputCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // è®¡ç®—ç‚¹å‡»ä½ç½®åœ¨ç”»å¸ƒä¸­çš„åæ ‡
            const canvasX = x * (outputCanvas.width / rect.width);
            const canvasY = y * (outputCanvas.height / rect.height);
            
            // æ£€æŸ¥ç‚¹å‡»äº†å“ªä¸ªåˆ‡ç‰‡
            for (let i = 0; i < slices.length; i++) {
                const slice = slices[i];
                if (canvasX >= slice.x && canvasX <= slice.x + slice.width &&
                    canvasY >= slice.y && canvasY <= slice.y + slice.height) {
                    alert(`æ‚¨ç‚¹å‡»äº†åˆ‡ç‰‡ ${i + 1} (ä½ç½®: ${slice.x},${slice.y} å°ºå¯¸: ${slice.width}Ã—${slice.height})`);
                    return;
                }
            }
        }
        
        // å¤„ç†ç”»å¸ƒæ‚¬åœ
        function handleCanvasHover(e) {
            if (!generated) {
                sliceTooltip.style.display = 'none';
                return;
            }
            
            const rect = outputCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // è®¡ç®—æ‚¬åœä½ç½®åœ¨ç”»å¸ƒä¸­çš„åæ ‡
            const canvasX = x * (outputCanvas.width / rect.width);
            const canvasY = y * (outputCanvas.height / rect.height);
            
            // æ£€æŸ¥æ‚¬åœåœ¨å“ªä¸ªåˆ‡ç‰‡ä¸Š
            hoveredSliceIndex = -1;
            for (let i = 0; i < slices.length; i++) {
                const slice = slices[i];
                if (canvasX >= slice.x && canvasX <= slice.x + slice.width &&
                    canvasY >= slice.y && canvasY <= slice.y + slice.height) {
                    hoveredSliceIndex = i;
                    break;
                }
            }
            
            if (hoveredSliceIndex >= 0) {
                const slice = slices[hoveredSliceIndex];
                sliceTooltip.textContent = `åˆ‡ç‰‡ ${hoveredSliceIndex + 1}`;
                sliceTooltip.style.display = 'block';
            } else {
                sliceTooltip.style.display = 'none';
            }
        }
        
        // ç§»åŠ¨å·¥å…·æç¤º
        function moveTooltip(e) {
            if (hoveredSliceIndex >= 0) {
                sliceTooltip.style.left = (e.clientX + 10) + 'px';
                sliceTooltip.style.top = (e.clientY + 10) + 'px';
            }
        }
        
        // ä¿å­˜å›¾ç‰‡ï¼ˆä¼˜åŒ–ç§»åŠ¨ç«¯ä½“éªŒï¼‰
        function saveImage() {
            if (!generated) {
                alert('è¯·å…ˆç”Ÿæˆå›¾ç‰‡');
                return;
            }
            
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶é“¾æ¥
            outputCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                
                // è®¾ç½®ä¸‹è½½å±æ€§
                link.download = `slices-${timestamp}.png`;
                link.href = url;
                
                // è§¦å‘ç‚¹å‡»äº‹ä»¶ï¼ˆå…¼å®¹ç§»åŠ¨ç«¯ï¼‰
                const event = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                
                // æ·»åŠ åˆ°DOMå¹¶è§¦å‘ç‚¹å‡»
                document.body.appendChild(link);
                link.dispatchEvent(event);
                document.body.removeChild(link);
                
                // é‡Šæ”¾URLå¯¹è±¡
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);
            }, 'image/png');
        }
        
        // é‡ç½®æ‰€æœ‰
        function resetAll() {
            // é‡ç½®å…¨å±€è®¾ç½®
            globalWidthPercent.value = 80;
            globalHeightPercent.value = 80;
            cornerRadius.value = 10;
            sliceColor.value = '#ff7eb9';
            positionType.value = 'center';
            
            // é‡ç½®é˜´å½±è®¾ç½®
            shadowEnabled.checked = false;
            shadowColor.value = '#000000';
            shadowBlur.value = 10;
            shadowOffsetX.value = 5;
            shadowOffsetY.value = 5;
            shadowOpacity.value = 50;
            
            // é‡ç½®æè¾¹è®¾ç½®
            strokeEnabled.checked = false;
            strokeColor.value = '#ffffff';
            strokeWidth.value = 2;
            strokeBlur.value = 0;
            strokeType.value = 'solid';
            dashPattern.value = '5,3';
            
            // æ›´æ–°æ˜¾ç¤º
            updateGlobalWidthPercent();
            updateGlobalHeightPercent();
            updateCornerRadius();
            updateShadowBlur();
            updateShadowOffsetX();
            updateShadowOffsetY();
            updateShadowOpacity();
            updateStrokeWidth();
            updateStrokeBlur();
            updateStrokeType();
            
            // é‡ç½®åˆ‡ç‰‡æ•°æ®
            if (slices.length > 0) {
                slices.forEach(slice => {
                    slice.widthPercent = 80;
                    slice.heightPercent = 80;
                    slice.visible = true;
                });
                createSliceControls();
            }
            
            // é‡ç½®ç”»å¸ƒ
            outputCanvas.width = 1;
            outputCanvas.height = 1;
            ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // é‡ç½®çŠ¶æ€
            generated = false;
            saveBtn.disabled = true;
            progressBar.style.width = '0%';
            progressText.textContent = 'å‡†å¤‡å°±ç»ª';
            hoveredSliceIndex = -1;
            sliceTooltip.style.display = 'none';
        }
        
        // åˆå§‹åŒ–
        initEventListeners();
        updateGlobalWidthPercent();
        updateGlobalHeightPercent();
        
        // æ£€æŸ¥æ˜¯å¦å·²æœ‰æœ‰æ•ˆçš„è®¸å¯è¯
        function checkExistingLicense() {
            // è¿™é‡Œå¯ä»¥æ·»åŠ æ£€æŸ¥æœ¬åœ°å­˜å‚¨ä¸­æ˜¯å¦æœ‰æœ‰æ•ˆè®¸å¯è¯çš„é€»è¾‘
            // å¦‚æœæœ‰ï¼Œå¯ä»¥è‡ªåŠ¨ç™»å½•
            
            // ç¤ºä¾‹: æ£€æŸ¥ç‰¹å®šå¡å¯†æ˜¯å¦æœ‰æ•ˆ
            // const testKey = "XY2024-ABCD-EFGH-IJKL";
            // const storageKey = STORAGE_PREFIX + testKey;
            // const storedData = localStorage.getItem(storageKey);
            // if (storedData) {
            //     try {
            //         const data = JSON.parse(storedData);
            //         const license = VALID_KEYS.find(k => k.key === testKey);
            //         if (license && (license.maxUses === 999 || data.used < license.maxUses)) {
            //             currentLicense = {
            //                 key: license.key,
            //                 maxUses: license.maxUses,
            //                 validUntil: license.validUntil,
            //                 used: data.used + 1
            //             };
            //             localStorage.setItem(storageKey, JSON.stringify({
            //                 used: currentLicense.used,
            //                 lastUsed: new Date().toISOString()
            //             }));
            //             authOverlay.style.display = 'none';
            //             mainContainer.style.display = 'block';
            //             updateLicenseInfo();
            //             return;
            //         }
            //     } catch (e) {
            //         console.error('è§£æå­˜å‚¨æ•°æ®å¤±è´¥', e);
            //     }
            // }
            
            // é»˜è®¤æ˜¾ç¤ºéªŒè¯ç•Œé¢
            authOverlay.style.display = 'flex';
            mainContainer.style.display = 'none';
        }
        
        // å¯åŠ¨æ—¶æ£€æŸ¥è®¸å¯è¯
        checkExistingLicense();
        
        // ç§»åŠ¨ç«¯æç¤º
        if (/Mobi|Android/i.test(navigator.userAgent)) {
            alert('æç¤ºï¼šåœ¨ç§»åŠ¨ç«¯ä¿å­˜å›¾ç‰‡æ—¶ï¼Œè¯·ä½¿ç”¨æµè§ˆå™¨çš„"é•¿æŒ‰å›¾ç‰‡â†’ä¿å­˜å›¾ç‰‡"åŠŸèƒ½ï¼Œæˆ–ç‚¹å‡»"ä¿å­˜å›¾ç‰‡"æŒ‰é’®');
        }
    </script>
</body>
</html>